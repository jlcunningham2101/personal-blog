"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.dialectConvert = exports.connect = exports.connectWithOptions = exports.connectWithSSL = void 0;
const dotenv_1 = __importDefault(require("dotenv"));
const sequelize_1 = require("sequelize");
dotenv_1.default.config();
/**
 * @method connectWithSSL Connect to batabase by ssl
 * @param params IConnectionProductionMode
 * @returns Sequelize
 */
function connectWithSSL(params) {
    return new sequelize_1.Sequelize(params.databaseURL, {
        dialectOptions: {
            ssl: {
                rejectUnauthorized: false,
            },
        },
        pool: {
            max: 5,
            min: 0,
            acquire: 30000,
            idle: 10000,
        },
        define: {
            freezeTableName: true,
            timestamps: true,
        },
        // logging: console.log, //(...msg) => { console.log(msg) },
        // benchmark: true
    });
}
exports.connectWithSSL = connectWithSSL;
/**
 * @method connectWithOptions Connect to database with options
 * @param params IConnectionDevelopmentMode
 * @returns Sequelize
 */
function connectWithOptions(params) {
    return new sequelize_1.Sequelize(params.database, params.username, params.password, {
        dialect: dialectConvert(params.dialect),
        dialectOptions: {
            host: params.host,
            port: params.port,
            user: params.username,
            password: params.password,
            database: params.database,
        },
        pool: {
            max: 5,
            min: 0,
            acquire: 30000,
            idle: 10000,
        },
        define: {
            freezeTableName: true,
            timestamps: false,
        },
        // logging: console.log,
        // benchmark: true,
    });
}
exports.connectWithOptions = connectWithOptions;
/**
 * @method connect Create a connection to database by Sequelize
 * @param params IConnection
 * @returns Sequelize
 */
function connect(params) {
    if (process.env.NODE_ENV === "production") {
        const connection = params;
        return connectWithSSL(connection);
    }
    else {
        const connection = params;
        return connectWithOptions(connection);
    }
}
exports.connect = connect;
/**
 * @method dialectConvert Convert a string to Dialect
 * @param dialect string | undefined
 * @returns Dialect
 */
function dialectConvert(dialect) {
    const mysql = "mysql";
    const postgres = "postgres";
    const sqlite = "sqlite";
    const mariadb = "mariadb";
    const mssql = "mssql";
    switch (dialect) {
        case "mysql":
            return mysql;
        case "postgres":
            return postgres;
        case "sqlite":
            return sqlite;
        case "mariadb":
            return mariadb;
        case "mssql":
            return mssql;
        default:
            return "postgres";
    }
}
exports.dialectConvert = dialectConvert;
